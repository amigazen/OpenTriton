\input amigatexinfo @c -*-texinfo-*-
\input texinfo
@comment %**start of header
@setfilename TritonDev.info
@settitle TritonDev
@iftex
@afourpaper
@end iftex
@finalout
@comment %**end of header

@c @setchapternewpage odd

@titlepage
@sp 5
@center @titlefont{Triton}
@sp 4
@center Release OpenTriton 2.0
@sp 4
@center @titlefont{Developer Documentation}
@sp 4
@center @copyright{} 1993-1998 by Stefan Zeiger.
@center All rights reserved.
@end titlepage

@node Top, INT_OVE, (dir), (dir)
@ifinfo

@center **********************************************

@center Triton

@center Release OpenTriton 2.0

@center Developer Documentation

@center (c) 1993-1998 Stefan Zeiger

@center **********************************************

@end ifinfo

@menu

Introduction

* Overview        :INT_OVE.       Programming with Triton
* OOP Internals   :INT_OOP.       The internal working of Triton
* Class Tree      :INT_CLA.       Available classes
* Autodocs        :INT_AUT.       Notes on the autodocs

Writing Applications - Step by Step Tutorial

* Applications    :TUT_APP.       The key to Triton
* Projects        :TUT_PRO.       Triton GUI windows
* Menus           :TUT_MEN.       Menus
* Objects         :TUT_OBJ.       Triton objects
* Layout          :TUT_LAY.       The layout engine
* Macros          :TUT_MAC.       Using the Triton GUI macros
* Polling Loop    :TUT_POL.       Handling GUI events
* Messages        :TUT_MES.       Sending messages
* Help            :TUT_HEL.       Providing help
* Requesters      :TUT_REQ.       Triton requesters

Class Authoring Tutorial

* Class Basics    :CLA_BAS.       The basic class layout
* Methods         :CLA_MET.       The default methods
* Frames          :CLA_FRA.       Frame Primitives
* Text            :CLA_TEX.       Text Primitives
* Image           :CLA_IMG.       Image Primitives
* Color           :CLA_COL.       Color Primitives

Style Guide

* Guidelines      :STY_OVE.       Guidelines for Triton GUIs

Odds & Ends

* Mailing list    :ODD_MAI.       About the Triton mailing list
* FAQ             :ODD_FAQ.       Frequently Asked Questions

* Index           :Index.

@end menu

@example
@*
@end example

@ifinfo
Note that all pages can be reached directly from this menu,
so that you may conveniently browse through all items in this
main menu in order to read the entire documentation.
@end ifinfo

@node INT_OVE, INT_OOP, Top, Top
@chapter Introduction
@cindex Introduction
@section Overview
@cindex Overview

The Triton GUI creation system offers an easy way to create good looking
GUIs for your applications. It can be used with a variety of
programming languages. Support for SAS/C is included directly in this
package. Check out the AmiNet directory @file{dev/gui} or the Triton
Home Page at @code{http://home.pages.de/~szeiger/triton.html} for
support files for other languages and development systems.

If you have released a Triton support package for a new language or
development system, please contact me for inclusion into the list on the
Triton home page.

This document describes how to use Triton in your own applications
by providing you with some overview topics and a step by step
introduction. It does @strong{not} describe in detail the functions,
structures, tags, etc@. which are used, so you should always look
them up in the autodocs file (see @ref{INT_AUT, Autodocs, Introduction - Autodocs})
and the C header file @file{Developer/Include/libraries/triton.h}.

The examples in this document assume that you're using the C support
files with the SAS/C compiler. There may be differences in other
languages or even with other C development systems.

@node INT_OOP, INT_CLA, INT_OVE, Top
@section OOP Internals
@cindex OOP Internals

Although Triton offers a mostly procedural API, it is based on an
object-oriented system. As a Triton user you will never see Triton
objects directly, but instead reference them through ID numbers.

@node INT_CLA, INT_AUT, INT_OOP, Top
@section Class Tree
@cindex Class Tree

The following classes are available in Triton:

@example
    Object                  Abstract root class
    `-- DisplayObject       Abstract class for window contents
        +-- Button          BOOPSI button gadget
        +-- CheckBox        GadTools CheckBox
        +-- Cycle           GadTools Cycle and MX gadget
        +-- DropBox         AppIcon dropping box
        +-- FrameBox        Framing or grouping box
        +-- Group           Triton's layout engine
        +-- Image           Image
        +-- Line            3D line
        +-- Listview        GadTools Listview
        +-- Palette         GadTools Palette gadget
        +-- Progress        Progress indicator
        +-- Scroller        GadTools Scroller
        +-- Slider          GadTools Slider
        +-- Space           Empty space
        +-- String          GadTools String gadget
        `-- Text            Text
@end example

Descriptions for all classes can be found in the Triton autodocs
(see @ref{INT_AUT, Autodocs, Introduction - Autodocs})
under @code{triton.library/class_<classname>}.

@node INT_AUT, TUT_APP, INT_CLA, Top
@section Autodocs
@cindex Autodocs

Documentation on all Triton classes and @file{triton.library} functions can be
found in the Triton autodocs file @file{Developer/Autodocs/triton.doc}. The
function descriptions follow the usual syntax as used in the AmigaOS autodocs.
The Triton classes are listed with the prefix @code{triton.library/class_} and
are described using the following keywords:

@itemize @bullet
@item @code{NAME}

The name of the class and a short description.
@item @code{SUPERCLASS}

The superclass. If the comment @code{(no attributes inherited)} is added,
all attributes (see below) are described in this autodoc clip. Otherwise
all attributes of the superclass are inherited.
@item @code{SYNOPSIS}

The tags which invoke the creation of an instance of the class. If the tags
are enclosed in parantheses the class is abstract and no instances can be
created.
@item @code{ATTRIBUTES}

The attributes which are created for every instance of the class. All
attributes are listed with their tag names, except for the default
attribute which is listed as @code{<Default>}. See above for superclass
attributes. A comment in square brackets denotes if an attribute can be
specified in a creation taglist, modified later with
@code{TROM_SETATTRIBUTE} or @code{TR_SetAttribute()} or queried with
@code{TROM_GETATTRIBUTE} or @code{TR_GetAttribute()}.
@item @code{APPLICATION MESSAGES}

This section describes all application messages (@code{TRMS_...}) which
objects of this class are currently able to send. If no messages are
described, this doesn't mean that none are sent. Not all class
descriptions have this section yet.
@item @code{OBJECT MESSAGES}

This section describes all messages which can be sent to instances of
this class. Deferred messages are listed in parantheses. Inherited
messages are not listed.
@end itemize

@node TUT_APP, TUT_PRO, INT_AUT, Top
@chapter Writing Applications
@cindex Tutorial
@section Applications
@cindex Applications

In order to use @file{triton.library} you must first of all open it, like any other
shared library, as described in the @code{Amiga ROM Kernel Reference Manual},
volume @code{Libraries}. Before quitting, you have to close it
again. The following code makes sure that you can use functions from
@file{triton.library} release 1.2 or higher:

@example
    #include <libraries/triton.h>
    #include <clib/triton_protos.h>
    #include <pragmas/triton_pragmas.h>

    struct Library *TritonBase;

    int main(void)
    @{
      if(TritonBase=OpenLibrary(TRITONNAME,TRITON12VERSION))
      @{
        /* Use functions from triton.library... */
        CloseLibrary(TritonBase);
      @}
      else
      @{
        /* React on the error... */
      @}
      return 0;
    @}
@end example

All Triton programs are based on a Triton application structure (struct TR_App).
This structure is the connection which keeps all Triton parts of your application
together. Before using any other Triton functions, you have to create a Triton
application, and you must delete it again before your program quits (and before
you close @file{triton.library} of course). Any Triton application must have at
least a short name, which is used by Triton to identify the application. All other
tags are optional. A typical code segment could look like this:

@example
    struct TR_App *myApp;

    if(myApp=TR_CreateAppTags(
      TRCA_Name,    "MyApp",
      TRCA_Release, "1.0",
      TRCA_Version, "42.113",
      TRCA_Date,    "3.11.94",
      TAG_END))
    @{
      /* Use myApp for other Triton functions... */
      TR_DeleteApp(myApp);
    @}
    else
    @{
      /* React on the error... */
    @}
@end example

The linker library @file{triton.lib} offers an easier way to open @file{triton.library}
and create a Triton application structure. The two examples from above can be combined
into the following short version:

@example
    #include <libraries/triton.h>
    #include <proto/triton.h>

    int main(void)
    @{
      if(TR_OpenTriton(TRITON12VERSION,
        TRCA_Name,    "MyApp",
        TRCA_Release, "1.0",
        TRCA_Version, "42.113",
        TRCA_Date,    "3.11.94",
        TAG_END))
      @{
        /* The opened application is called 'Application' */
        TR_CloseTriton();
      @}
      else
      @{
        /* React on the error... */
      @}
      return 0;
    @}
@end example

@node TUT_PRO, TUT_MEN, TUT_APP, Top
@section Projects
@cindex Projects

A Triton Project is the next smaller entity of a Triton GUI. Currently
a project contains exactly one Intuition window, but in future versions
of Triton it could be possible to attach more windows to a project.
Upon opening a project, you have to specify all objects which are to
be displayed in the window, the window's menu and some tags describing
window properties.

At first you have to specify the window properties, then the menus and
finally one (!) object. Normally this object will be a group which contains
other objects or groups.

Note that all tags are optional. You may just as well
open a window without any tags. This will result in a small window, consisting
only of the close and depth gadget and a small dragging bar, being opened
over the default public screen's title bar.

As with naming Triton applications,
you should give each project at least a unique ID which is used by Triton
e.g. for remembering the window dimensions.

Opening and closing a
project without any objects and menus could look like this:

@example
    struct TagItem dummyTags=
    @{
      TRWI_Title, (ULONG) "A dummy window",
      TRWI_ID,            42,
      TAG_END
    @};

    void dummyFunction(void)
    @{
      struct TR_Project *dummyProject;

      if(dummyProject=TR_OpenProject(Application,dummyTags))
      @{
        /* Opened successfully */
        TR_CloseProject(dummyProject);
      @}
      else
      @{
        /* React on the error... */
      @}
    @}
@end example

Of course, this way of opening a project via a static TagItem list doesn't
allow insertion of object parameters or localized strings. Since you need these
features most times, you should instead use a dynamic TagList which is built
on the stack at runtime. Be sure to set a large enough stack! Some development
systems offer automatic stack setting in their startup code, which comes
handy in those situations. Please do not rely on the user to set the
stack!

Note that it is currently not possible to use @code{TAG_MORE},
@code{TAG_SKIP} and @code{TAG_IGNORE} with Triton taglists.

And now back to our code, this time with a dynamic list. Imagine a function
@code{STRPTR GetLocStr(int num)} which gives you a localized string.

@example
    void dummyFunction(void)
    @{
      struct TR_Project *dummyProject;

      if(dummyProject=TR_OpenProjectTags(Application,
        TRWI_Title, (ULONG) GetLocStr(MSG_WINTITLE_DUMMY),
        TRWI_ID,            42,
        TAG_END))
      @{
        /* Opened successfully */
        TR_CloseProject(dummyProject);
      @}
      else
      @{
        /* React on the error... */
      @}
    @}
@end example

The ID 42 in the above examples has been chosen randomly. This is no
problem as long as you stick to this ID in future updates of your application.
Otherwise the window dimensions would be wrong and the user would have to
adjust them again.

In order to not use IDs twice, it can be useful to enumerate them:

@example
    enum windowIDs @{WINID_DUMMY=1, WINID_FOO, WINID_BAR@};
@end example

Note that window IDs must be different from 0. 0 is equal to
no ID at all.

See the autodoc clip @code{triton.library/TR_OpenProject()} for details
about the supported tags.

@node TUT_MEN, TUT_OBJ, TUT_PRO, Top
@section Menus
@cindex Menus

Any project definiton may contain menus. The menu tags must follow
the window tags immediately, before the object tags. If a menu has
an object ID, the TRAT_ID tag must be the last one in the menu
definition.

Object IDs are more than Project IDs. Project IDs are
used only internally by Triton. As an application programmer, you
have to reference Projects by a pointer to their @code{struct TR_Project}.
Objects instead are referenced only through
object IDs. The same is true for menus, which use ordinary object IDs.

A typical menu defintion could look like this:

@example
    TR_OpenProjectTags(...
      TRMN_Title,   (ULONG) "Project",
        TRMN_Item,  (ULONG) "?_About",       TRAT_ID, 1,
        TRMN_Item,  (ULONG) TRMN_BARLABEL,   TRAT_ID, 2,
        TRMN_Item,  (ULONG) "Q_Quit",        TRAT_ID, 3,
      ...);
@end example

The title of a menu item or sub-item can be @code{TRMS_BARLABEL}
to insert a standard separator bar. Keyboard shortcuts can be
specified by beginning the menu label with the shortcut key
followed by an underscore character and the real menu label.
These simple shortcuts (with the right Amiga key) are processed
automatically. You can create a so-called 'extended shortcut'
by starting a label with an underscore character, then the
text for the shortcut, another underscore and the menu label.
These extended shortcuts are only displayed with AmigaOS 3.0
or higher and they are not managed automatically. You have to
listen to incoming keyboard events in order to handle
these shortcuts yourself.

See the @code{Menus} window of the Triton demo application for a
more detailed example on menus.

@node TUT_OBJ, TUT_LAY, TUT_MEN, Top
@section Objects
@cindex Objects

The heart of every Triton GUI is objects. Currently only instances
of subclasses of the @code{DisplayObject} class can be created.
@xref{INT_CLA, Class Tree, Introduction - Class Tree}, for a short list
of all classes. Detailed descriptions can be found in the autodocs.

Objects are created by inserting an object tag into a project definition.
For example, a checked CheckBox object with an ID of 99 can be created
the following way:

@example
    TROB_CheckBox,   NULL,
      TRAT_Value,    (ULONG) TRUE,
      TRAT_ID,       99,
@end example

All available tags are listed in the autodocs. The @code{<Default>} tag's
value has to be inserted directly in the @code{TROB_<Class>} tag as its
data. All other tags are inserted normally after the initial class tag.

@cindex Notification
@cindex Linking
@strong{Note:} It is useful to @code{enum}erate object IDs as with
project IDs. But in contrast to project IDs, object IDs may be used
more than once. If you use an object ID several times within the same
project, the objects with that ID will be linked together and whenever
an attribute (only selected attributes, notably @code{TRAT_Value}!) of
one object changes, this change will be broadcast to all other objects
with that ID as if you had notified them yourself with
@code{TR_SetAttribute()}. This is particularly useful to link a
CheckBox gadget and a checkable menu item together.

See the @code{Connections} window of the Triton demo application for a
more detailed example on attribute broadcasting.

@node TUT_LAY, TUT_MAC, TUT_OBJ, Top
@section Layout
@cindex Layout

Triton's layout engine is implemented through the @code{Group}
class. @code{Space} objects also play an important role because (apart
from a few exceptions) groups don't contain any 'empty' space. Instead
this space is covered by instances of class @code{Space}. See the
example below for details about spaces.

@code{Group} objects can create both vertical and horizontal groups,
depending on whether they are created with @code{TRGR_Vert} or
@code{TRGR_Horiz}.

Four different layout types are available for each instance
of @code{Group} (adjustable with the group flags). They affect
the primary direction only:

@enumerate
@item
@code{TRGR_PROPSHARE}: Expands all objects proportionally to their
minimum size. All spaces retain their minimum size and are not resizable.
Non-resizable non-space objects do also retain their minimum sizes
(well, they don't really have a choice, do they? ;).
@item
@code{TRGR_EQUALSHARE}: Same as @code{TRGR_PROPSHARE} except that all non-space
objects have the same size. Their minimum size equals the biggest minimum size
of the individual objects.
@item
@code{TRGR_PROPSPACES}: All non-space objects retain their minimum sizes all
the time and do not get stretched. Instead the spaces are stretched
proportionally to their minimum sizes.
@item
@code{TRGR_ARRAY}: This group builds the top group of an array. In order
to create an array, you have to set up an outer @code{TRGR_ARRAY} group
(horizontal for a column array, vertical for a line array) and fill it
with single objects (notably spaces) or @code{TRGR_PROPSHARE} groups in
the opposite direction. All elements of the inner groups will be aligned
to build an array. Inner groups which have the flag @code{TRGR_INDEP} set
will not be aligned. This flag is mainly used to insert named separator bars
(created with @code{TROB_Line} and @code{TROB_Text}) into an array.
@end enumerate

Currently the only objects which are treated as spaces in the above scheme
are instances of class @code{Space}.

The behaviour of the group in its secondary direction can be changed, too.
Two additional flags are available for that purpose. In most cases you may
want to set both of them:

@enumerate
@item
@code{TRGR_ALIGN}: All resizable objects (i.e. resizable in the secondary
dimension of the group) are strechted to fit the full space occupied by
the group.
@item
@code{TRGR_CENTER}: All non-resizable objects are centered in the group.
Without this flag they get aligned to the left or top border.
@end enumerate

It is also possible to keep a group at its minimum size and now allow
it to be stretched in either or both directions. This can be accomplished
with the @code{TRGR_FIXHORIZ} and @code{TRGR_FIXVERT} flags.

A group can be created like any other object. It takes other objects
as its arguments. Every group has to be terminated with a @code{TRGR_End}
tag. A typical horizontal group, which contains a CheckBox, a space and
again a CheckBox, would look like this:

@example
    TRGR_Horiz,      TRGR_PROPSHARE|TRGR_ALIGN|TRGR_CENTER,

      TROB_CheckBox, 0,
        TRAT_ID,     1,

      TROB_Space,    TRST_NORMAL,

      TROB_CheckBox, 0,
        TRAT_Value,  TRUE,
        TRAT_ID,     2,

      TRGR_End,      0
@end example

See the @code{Groups} window of the Triton demo application for a
more detailed example on groups and arrays.

@node TUT_MAC, TUT_POL, TUT_LAY, Top
@section Macros
@cindex Macros

The C header file @file{Developer/Include/libraries/triton.h} contains
many macro definitions which make creating a Triton GUI much
easier. With the help of the preprocessor @code{Mac2E}, these macros
are also available in @code{AmigaE}. Other languages or compilers may
support similar or different macros or none at all. If no macros are
available in your development system, you have to do it the traditional
way. If you can use macros, use them.

The static taglist definition can be written a bit simpler with macros:

@example
    ProjectDefinition(dummyTags)
    @{
      /* Insert project tags here */
    @};
@end example

But the main use for macros are the tags themselves. For example, the tags
from the dummy window example (see @ref{TUT_PRO, Projects, Tutorial - Projects})
would look like this:

@example
      WindowTitle("A dummy window"),
      WindowID(42),
      EndProject
@end example

Have a look at the macro definitions and the supplied demo applications
for more detailed information about the macros.

@node TUT_POL, TUT_MES, TUT_MAC, Top
@section Polling Loop
@cindex Polling Loop
@cindex Loop, Polling

After creating a GUI you have to handle user input. In order to accomplish
this task, Triton offers a polling system which resembles the Intuition
IDCMP polling system. A basic polling loop looks like this:

@example
    void handleDummyWindow(void)
    @{
      BOOL closeMe=FALSE;
      struct TR_Message *trMsg;

      /* Open the window... */

      while(!closeMe)
      @{
        TR_Wait(Application,NULL);
        while(trMsg=TR_GetMsg(Application))
        @{
          switch(trMsg->trm_Class)
          @{
            case TRMS_CLOSEWINDOW:
              closeMe=TRUE;
              break;

            case TRMS_ACTION:
              switch(trmsg->trm_ID)
              @{
                case ID_FOO:
                  /* Do something... */
                  break;
                case ID_BAR:
                  /* Do something... */
                  break;
              @}
              break;

            case TRMS_NEWVALUE:
              switch(trMsg->trm_ID)
              @{
                /* New value is in trMsg->trm_Data */

                case ID_MYCHECKBOX:
                  /* Do something... */
                  break;
                case ID_MYSLIDER:
                  /* Do something... */
                  break;
              @}
              break;

            case TRMS_ERROR:
              puts(TR_GetErrorString(trMsg->trm_Data));
              break;
          @}
          TR_ReplyMsg(trMsg);
        @}
      @}

      /* Close the window... */
    @}
@end example

@strong{Note:} Don't forget to reply all messages!

You could add a @code{switch()} for the project which sent the message if
you have more than one project opened, but a better way is to use unique
object IDs. This does also yield the advantage that moving an object from
one window to another does not require any change in the message handling.

It is currently not very well documented which messages are sent by the
different objects. As a general rule, activateable objects send @code{TRMS_ACTION}
and objects which have a @code{TRAT_Value} or a similar modifiable attribute,
send @code{TRMS_NEWVALUE}.

Here is a more detailed description of the message types:

@itemize @bullet
@item
@code{TRMS_CLOSEWINDOW}: The user has pressed the close gadget or the @code{Esc} key
(if it hasn't been disabled with @code{TRWF_NOESCCLOSE}).
@item
@code{TRMS_ERROR}: An error occured. @code{TR_Message.trm_Data} contains the error
code. You can use @code{TR_GetErrorString()} to generate a user-readable error
message from this error code.
@item
@code{TRMS_NEWVALUE}: An object's attribute has changed. @code{TR_Message.trm_Data} contains
the new value for the attribute.
@item
@code{TRMS_ACTION}: An object has been activated somehow (e.g. a button has been pressed
or its keyboard shortcut was used instead).
@item
@code{TRMS_ICONDROPPED}: An icon has been dropped over a window.
You will get this message only if an object in your
window reacts on dropped icons or you ask directly for it by
specifying the project flag @code{TRWF_APPWINDOW}. Otherwise
Workbench will not allow you to drop icons over a Triton window.
@code{TR_Message.trm_ID} contains the ID of the object over which the
icon was dropped or 0 if it was dropped over an object without an ID.
@code{TR_Message.trm_Data} contains a pointer to the @code{struct AppMessage}
which was sent by Workbench.
@item
@code{TRMS_KEYPRESSED}: A key has been pressed and Triton was unable to
identify it (e.g. as a keyboard shortcut).
@code{TR_Message.trm_Data} contains the ASCII code (if available,
otherwise 0),
@code{TR_Message.trm_Code} contains the RawKey code and @code{TR_Message.trm_Qualifier}
the qualifier bits.
@item
@code{TRMS_HELP}: The user requests help for the object specified by @code{TR_Message.trm_ID}
or for the whole window if the ID is 0.
@end itemize

A description of all fields of the @code{TR_Message} structure can be found in
the C header file @file{Developer/Include/libraries/triton.h}.

@node TUT_MES, TUT_HEL, TUT_POL, Top
@section Messages
@cindex Set
@cindex Get
@cindex Message
@cindex Attribute
@cindex Query
@cindex Modify

Sometimes you may wish to query an object's attribute directly
without waiting in a polling loop and then storing its value somewhere
else. This is especially useful for string gadgets. You should
@emph{not} read their contents when you receive a @code{TRMS_NEWVALUE}
message, because it is possible to exit a string gadget without
triggering such a message. Instead you have to read the contents
directly before you need them.

Attributes can be read with the @code{TR_GetAttribute()} function,
which will return the value of an object's or project's attribute.
Specify the object's ID or 0 for a project attribute. You can get
the default attribute of an object by setting @code{Attribute} to
0. Otherwise set it to an attribute tag. Checkable menu items support
the @code{TRAT_Value} attribute which is set to 0 if the menu item is
not checked and a non-0 value if it is checked.

Setting a new attribute works the same way with the function
@code{TR_SetAttribute()}. Again you may also modify project attributes.
See the autodoc clip for a list of them. After setting a new attribute
the on-screen representation of it will be updated if necessary.

If you want to send custom object messages (@code{TR_SetAttribute()} and
@code{TR_GetAttribute()} invoke the messages @code{TRDM_SETATTRIBUTE}
and @code{TRDM_GETATTRIBUTE}), you have to use
@code{TR_SendMessage()}. The autodocs will tell you which classes accept
which messages.

@emph{Note:} Do not confuse @code{Object Messages} (@code{TROM_...}) which are sent
to Triton objects with @code{Application messages} (@code{TRMS_...})
which you receive in your message polling loop.

@node TUT_HEL, TUT_REQ, TUT_MES, Top
@section Help
@cindex Help
@cindex QuickHelp

Triton offers two ways of providing help for the user of a Triton
application:

@itemize @bullet
@item
QuickHelp

@code{QuickHelp} creates and handles requester bubbles (actually they are
implemented as rectangular boxes at the moment). All you have to do is
provide a @code{TRDO_QuickHelpString} attribute for every object which
should have QuickHelp available. Then switch on QuickHelp with @code{TRWI_QuickHelp}
(can be set when opening a project or modified later with @code{TR_SetAttribute()}).
When the user moves the mouse pointer over an object which has a QuickHelp string
attached, a small window will pop up near the object where the mouse pointer is
located. This window contains the specified QuickHelp string. As soon as the mouse
pointer leaves the borders of the object, the help window will disappear.
@item
Manual help

If you set @code{TRWF_HELP} when opening a project, you will receive a @code{TRMS_HELP}
message whenever the user presses the @code{Help} key. As usual @code{TR_Message.trm_ID}
contains the ID of the object for which the user requested help or 0 if no object could
be assigned to the help request (you should normally provide help for the whole window
in that case). The most common way to react on @code{TRMS_HELP} is to pop up an AmigaGuide
document describing the object for which the user requested help. If you do not want to
provide more extensive help than you do with the QuickHelp feature (see above), you can
also pop up a requester containing the QuickHelp string for the specified object. The main
window of the main Triton demo application shows how to do that.
@end itemize

@node TUT_REQ, CLA_BAS, TUT_HEL, Top
@section Requesters
@cindex Requesters

Triton offers two requester functions:

@itemize @bullet
@item
@code{TR_EasyRequest()} creates and handles a simple requester
with some lines of text (different text styles are possible) and
a row of buttons at the lower end. You should use this function
whenever possible. Not only is it easier to use than @code{TR_AutoRequest()},
but it could be made user-configurable in future Triton releases.
@item
@code{TR_AutoRequest()} is a simple message polling loop which opens
a Triton window, waits until a @code{TRMS_ACTION} message comes in and
returns the ID of the object which triggered the message. This function
is often used in combination with the requester macros
(@code{BeginRequester()}, @code{BeginRequesterGads} and @code{EndRequester}).
@end itemize

Please consult the autodocs for more detailed information about these
functions. The main demo application contains examples for both types
of requesters.

If you need a more sophisticated requester (e.g. a string requester),
you have to use your own message polling loop
(see @ref{TUT_POL, Polling Loop, Tutorial - Polling Loop}).
You may still use the requester macros though.

@node CLA_BAS, CLA_MET, TUT_REQ, Top
@chapter Writing Classes
@section Class Basics
@cindex Class Basics
@cindex Class

This chapter contains information on how to create your own custom
classes to be used by Triton. At the moment your classes may inherit
only from @code{Object} and @code{DisplayObject}.

Triton is using a singe class tree. All classes inherit directly or
indirectly from @code{Object} and all classes (apart from
@code{Object} of course) inherit directly from exactly one parent
class, their @emph{super-class}.

While we're at it, let's define another term used in this tutorial: A
@emph{meta-class} in Triton is a class which is used to dispatch a
method to an object. Thus it is either the @emph{real} class of the
object or one of its @emph{ancestors}.

As you've already learned by using the built-in classes of Triton the
API of a class is defined by class and attribute tags. Note that a class
can be bound to more than one class tag. An example is
@code{Group} which is bound to @code{TRGR_Horiz} and
@code{TRGR_Vert}. You can make up your own tags by creating a number
based on @code{TRTG_OBJ} or @code{TRTG_OAT} and adding
@code{TRTG_SER(1)}. Serial number 0 is used by the built-in classes and
serial numbers above 1 will be used in the future by public custom classes.

The interior of a class consits of a structure conatining whatever
internal data the class needs to keep track of and a number of functions
representing the class' methods.

I suggest you use the following naming conventions:

@itemize @bullet
@item
All tags use mixed capitalization. Class tags are prefixed by
@code{TROB_} (@emph{Triton Object}) and attribute tags by @code{TRAT_}
(@emph{Triton Attribute}). In order to avoid naming conflicts it is
advisable to repeat the class name in the attribute tag names (example:
@code{TRAT_SomeClass_SomeAttribute}).

@item
The class data structure is named after the class, using mixed
capitalization and prefixed by @code{TROD_} (@emph{Triton Object
Data}).

@item
The method function names consist of the following parts, separated by
underscores: @code{TROM} (@emph{Triton Object Message}), the class name
(using mixed capitalization) and the method name (upper case).
@end itemize

The method functions return an @code{unsigned long} value and take the
following arguments:

@enumerate
@item
@code{struct TROD_<Class> * object}

This is a pointer to the object on which the method should be
performed. It is always casted to the metaclass type even if it is an
instance of a descendant.
@item
@code{ULONG messageid}

This is the ID of the message that was sent. Currently only a set of
pre-defined message IDs are allowed here. It's mainly used for finding
the correct superclass method to call.
@item
@code{struct TROM_<MessageData> * data}

This is the data associated with the message. It can actually be of any
type. Most of the standard messages use data structures following the
above convention.
@item
@code{struct TR_Class * metaclass}

This is the class which is currently processing the message, i.e. the
class with which the current method function is associated. You need it
for calling superclass methods (@code{...metaclass->trc_SuperClass...}).
@end enumerate


@node CLA_MET, CLA_FRA, CLA_BAS, Top
@section Methods
@cindex Method

Methods are performed on Triton objects by sending Object Messages to them.

Descriptions of all messages and the data structures associated with them
can be found in the C header file
@file{Developer/Include/libraries/triton.h}.

@node CLA_FRA, CLA_TEX, CLA_MET, Top
@section Frames
@cindex Frame
@cindex Frame Primitives

Your own classes can (and should) use the Triton frame primitives for
drawing frames (aka BevelBoxes). All available frame types are listed in
the @code{TR_FrameTypes} enumeration. Currently 3 different kinds of
frame types are available:

@enumerate
@item
GadTools @code{BBFT_#?} style frames:

The 3 standard frame styles already known from GadTools are also
available in Triton: @code{TRFT_BUTTON} is the most basic frame type, a
simple raised bevelled box. @code{TRFT_RIDGE} is a double frame as used
by GadTools string gadgets. @code{TRFT_ICONDROPBOX} is a double frame
with some free space between the two borders as used by standard Amiga
icon drop boxes.
@item
Additional low-level frame types:

Triton offers some additional frame styles, namely
@code{TRFT_XENBUTTON1}, @code{TRFT_XENBUTTON2} and
@code{TRFT_NEXTBUTTON}, which are used to create XEN and NeXT style
frames.
@item
Abstract frame types:

The third kind of frame types are abstract frame types which do not have
a fixed look but a defined meaning (e.g. a button frame or a group
frame). The look of these frame types can be configured by the user via
the Triton preferences editor.
@end enumerate

Before drawing a frame you usually have to know how big the borders will
become. This can be accomplished with the @code{TR_FrameBorderWidth()}
and @code{TR_FrameBorderHeight()} functions.

Then you can draw a frame using @code{TR_DrawFrame()}. The parameters of
this function are all quite straight-forward, except for the last
one. Its meaning depends on the kind of frame type. In the case of a
low-level frame type, setting @code{inverted} to @code{TRUE} causes the
frame to appear recessed instead of raised. In the case of an abstract
frame type the user preferences decide whether a frame should be raised
or recessed. Setting @code{inverted} to @code{TRUE} causes Triton to use
the opposite of the user preferences.

@node CLA_TEX, CLA_IMG, CLA_FRA, Top
@section Text
@cindex Text
@cindex Text Primitives

Similarly to the frame primitives there are also text primitives
available for writing your own classes.

The usage is quite straight-forward: First, find out the width of a line
of text by calling @code{TR_TextWidth()} if necessary. Second, draw the
text into a window using @code{TR_PrintText()}. You should supply the
same flags to both functions, selectable from the @code{TRTX_*}
flags. The following flags are currently available:

@itemize @bullet
@item
@code{TRTX_NOUNDERSCORE}

Underscores (as specified by the @code{TRWI_Underscore} project tag)
will not be interpreted and simply treated as normal text characters.
@item
@code{TRTX_HIGHLIGHT}

The text will be highlighted, i.e. drawn using the pen for highlighted
text instead of the one for normal text.
@item
@code{TRTX_3D}

The text will be drawn in the highlighting color with a shadow to the
lower right side.
@item
@code{TRTX_BOLD}

The text will be drawn using the @code{bold} (soft)style. Note that this
is not supported by all fonts.
@item
@code{TRTX_TITLE}

This is an abstract style which can be set by the user via the
Preferences editor to either normal, highlighted or shadowed text. It is
used for all kinds of titles (e.g. of framing boxes).
@end itemize

@node CLA_IMG, CLA_COL, CLA_TEX, Top
@section Images
@cindex Image
@cindex Image Primitives

You can use @code{TR_AreaFill()} for filling an area with one of
Triton's default backfill pattern. See the AutoDocs for more details.

When you get a @code{TROM_INSTALL} message you can assume that your
drawing area is filled with the background color the object's container
(@code{TROD_DisplayObject.tro_BackfillType}).

@node CLA_COL, STY_OVE, CLA_IMG, Top
@section Color
@cindex Color
@cindex Color Primitives

IF you want to draw your own shapes, other than texts, frames and the
other ones which can be drawn with the primitives, you can use the
normal graphics.library and intuition.library functions. Of course you
need to take care of the colors you use yourself. In addition to the
default system pens Triton offers its own pen selection scheme.

You can get a Triton pen with the @code{TR_GetPen()} function. As of V6
the following pen types are available:

@itemize @bullet
@item
@code{TRPT_TRITONPEN}

Triton's own pens. These are in concept similar to the system pens, but
Triton offers some additional ones. These pens can also be redefined by
the user with the Triton Preferences program.
@item
@code{TRPT_SYSTEMPEN}

The intuition DrawInfo pens. PenData specifies which pen to return.
@item
@code{TRPT_GRAPHICSPEN}

A standard graphics pen. @code{TR_GetPen()} will simply return the
PenData code as a pen number.
@end itemize

@node STY_OVE, ODD_MAI, CLA_COL, Top
@chapter Style Guide
@section Guidelines
@cindex Guidelines
@cindex Style Guide

Please keep the following general rules in mind when designing
and implementing a GUI with Triton:

@itemize @bullet
@item
Window size

Please make sure that all windows of your GUI fit on a standard
@code{PAL Hires} screen (640*256 pixels) with @file{topaz.font} in size 8.
@item
Keyboard shortcuts

Please add keyboard shortcuts to as many gadgets and menus as possible.
It is very annoying for a user who works without a mouse most of the
time to grab his mouse just because you forgot to add keyboard shortcuts.
@item
Test your GUI

You should always test your GUI with different font sizes (especially
fixed-width and proportional fonts with different heights) and a
non-standard window background to avoid making assumptions about
the layout and coloring of your GUI resulting from observed behaviour,
which is quite often wrong. Take special care not to use text spaces
for spacing in your GUI (e.g. in array labels).
@item
Stack size

If your application requires a stack size above 4096 bytes (e.g. because
of a huge TagList with a Triton project definition which is created on the
stack during runtime), make sure that the stack does indeed have that size.
Some development systems offer an automatic stack setting in their startup
code, which comes handy in those situations. Please do not rely on the user
to set the stack!
@item
And finally:

Don't forget the @code{Amiga User Interface Style Guide}...
@end itemize

@node ODD_MAI, ODD_FAQ, STY_OVE, Top
@section Mailing list
@cindex Mailing list
@cindex Triton mailing list

There is a mailing list for discussions and questions about Triton. If you have
any problems with Triton or simply want to get in touch with other developers
who are using Triton, you can subscribe to the list.

In that case, send EMail to majordomo@@mail.im.net with any subject and the line
@code{subscribe triton} in the body of your message. If you want the list mail to be
sent to a different EMail address (and @emph{only} if you want this), please use
@code{subscribe triton a.different@@email.address} instead (after replacing
@code{a.different@@email.address} with the address to send the mail to of course).

In order to unsubscribe from the list, simply follow the above rules, replacing
@code{subscribe} by @code{unsubscribe}.

If you need more help, send mail to majordomo@@mail.im.net with a line
@code{help} in the body.

@node ODD_FAQ, Index, ODD_MAI, Top
@chapter Odds & Ends
@section FAQ
@cindex FAQ
@cindex Frequently Asked Questions
@cindex Questions
@cindex Answers

Here are some frequesntly asked questions and their answers:

@enumerate
@item
Q: Why shouldn't I use a simple @code{TR_Wait()} for dummy windows?

A: Triton has to process inputs from Intuition. This is done in
@code{TR_GetMsg()}. But of course you have to call this functions
so that Triton can process its input. After @code{TR_Wait()}
returns, you have to run though a @code{while(TR_GetMsg())} loop
as usual. An easier way to create a dummy window is using
@code{TR_AutoRequest()}.
@item
Q: How do I handle a progress indicator?

A: As already explained in answer 1, you have to call @code{TR_GetMsg()}
regularly. When a progress indicator is displayed, you should update
it regularly and run through a @code{while(TR_GetMsg())} loop every time.
See the supplied Progress Indicator demo application for details.
@item
Q: How do I activate a string gadget?

A: Beginning with Triton 1.3 (V4) you can use @code{TR_SendMessage(Project,ID,TROM_ACTIVATE,NULL)}.
@end enumerate

@node Index, , ODD_FAQ, Top
@unnumbered Index
@printindex cp
@contents
@bye
